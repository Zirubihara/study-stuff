\documentclass[a4paper,11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[polish]{babel}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{geometry}
\geometry{margin=2cm}

% Konfiguracja kolorów dla listingów
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

% Styl dla Pythona
\lstdefinestyle{pythonstyle}{
    language=Python,
    backgroundcolor=\color{backcolour},
    commentstyle=\color{codegreen},
    keywordstyle=\color{blue}\bfseries,
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    numbers=left,
    numbersep=5pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=2,
    frame=single,
    rulecolor=\color{black}
}

\lstset{style=pythonstyle}

\title{Porównanie Bibliotek Wizualizacyjnych w Python\\
\large Listingi Kodu do Pracy Magisterskiej}
\author{Twoje Imię}
\date{\today}

\begin{document}

\maketitle
\tableofcontents
\newpage

% ============================================================================
\section{Wykres 1: Execution Time Comparison}
% ============================================================================

\subsection{Plotly - Najkrótsza Implementacja (8 LOC)}

Listing~\ref{lst:chart1_plotly} przedstawia implementację w Plotly Express,
charakteryzującą się najkrótszym kodem (8 linii).

\begin{lstlisting}[caption={Chart 1: Execution Time - Plotly Implementation},label={lst:chart1_plotly}]
df = Chart1_ExecutionTime.prepare_data(dp_data)

fig = px.bar(
    df, x='Library', y='Time', color='Library',
    title='Data Processing Performance - 10M Dataset',
    labels={'Time': 'Total Execution Time (seconds)'},
    color_discrete_sequence=Config.DP_COLORS
)

fig.update_layout(
    width=800, height=500, showlegend=False
)

fig.write_html('chart1_execution_time.html')
\end{lstlisting}

\textbf{Zalety:}
\begin{itemize}
    \item Deklaratywne API - wszystkie parametry w jednym wywołaniu
    \item Wbudowane kolory i styling
    \item Automatyczne tooltips (hover)
    \item 68\% mniej kodu niż Bokeh
\end{itemize}

\subsection{Bokeh - Niskopoziomowe API (25 LOC)}

Listing~\ref{lst:chart1_bokeh} pokazuje implementację w Bokeh,
wymagającą znacznie więcej kodu ze względu na niskopoziomowe API.

\begin{lstlisting}[caption={Chart 1: Execution Time - Bokeh Implementation},label={lst:chart1_bokeh}]
df = Chart1_ExecutionTime.prepare_data(dp_data)

# Manual data source creation
source = ColumnDataSource(data=dict(
    libraries=df['Library'].tolist(),
    times=df['Time'].tolist(),
    colors=[Config.DP_COLORS[i] for i in range(len(df))]
))

# Figure creation with explicit parameters
p = figure(
    x_range=df['Library'].tolist(),
    title="Data Processing Performance - 10M Dataset",
    toolbar_location="above",
    tools="pan,wheel_zoom,box_zoom,reset,save",
    width=800, height=500
)

# Add bars
p.vbar(x='libraries', top='times', width=0.7, 
       color='colors', source=source)

# Manual hover tooltip configuration
hover = HoverTool(tooltips=[
    ("Library", "@libraries"),
    ("Time", "@times{0.00} seconds")
])
p.add_tools(hover)

# Axis styling
p.xaxis.axis_label = "Library"
p.yaxis.axis_label = "Total Execution Time (seconds)"
p.xgrid.grid_line_color = None

output_file('chart1_execution_time.html')
save(p)
\end{lstlisting}

\textbf{Wady:}
\begin{itemize}
    \item Wymaga manualnego tworzenia ColumnDataSource
    \item Każdy element (osie, tooltips, grid) konfigurowany osobno
    \item 3x więcej kodu niż Plotly
    \item Imperatywny styl (więcej boilerplate)
\end{itemize}

\subsection{Matplotlib - Publikacje Naukowe (20 LOC)}

\begin{lstlisting}[caption={Chart 1: Execution Time - Matplotlib (PNG 300 DPI)},label={lst:chart1_matplotlib}]
df = Chart1_ExecutionTime.prepare_data(dp_data)

fig, ax = plt.subplots(figsize=(10, 6))

x = np.arange(len(df))
bars = ax.bar(x, df['Time'], 
              color=Config.DP_COLORS[:len(df)],
              edgecolor='black', linewidth=1.5, alpha=0.8)

# Manual bar labels
for bar in bars:
    height = bar.get_height()
    ax.text(bar.get_x() + bar.get_width()/2., height,
            f'{height:.2f}s',
            ha='center', va='bottom', 
            fontsize=10, fontweight='bold')

ax.set_xlabel('Library', fontsize=12, fontweight='bold')
ax.set_ylabel('Total Execution Time (seconds)', 
              fontsize=12, fontweight='bold')
ax.set_title('Data Processing Performance - 10M Dataset',
             fontsize=14, fontweight='bold', pad=20)
ax.set_xticks(x)
ax.set_xticklabels(df['Library'], fontsize=11)
ax.grid(axis='y', alpha=0.3, linestyle='--')

plt.tight_layout()
plt.savefig('chart1_execution_time.png', 
            dpi=300, bbox_inches='tight')
plt.close()
\end{lstlisting}

\textbf{Zastosowanie:}
\begin{itemize}
    \item Najlepsza jakość dla publikacji (300 DPI)
    \item Format PNG/PDF - kompatybilny z LaTeX
    \item Precyzyjna kontrola nad każdym elementem
    \item Standard w publikacjach IEEE/ACM
\end{itemize}

% ============================================================================
\section{Wykres 2: Operation Breakdown - Grouped Bars}
% ============================================================================

\subsection{Kluczowe Różnice: Plotly vs Bokeh}

Wykres z grupowanymi słupkami (6 operacji × 5 bibliotek) pokazuje
największe różnice między bibliotekami.

\subsubsection{Plotly - Automatyczne Grupowanie}

\begin{lstlisting}[caption={Chart 2: Grouped Bars - Plotly (10 LOC)},label={lst:chart2_plotly}]
df = Chart2_OperationBreakdown.prepare_data(dp_data)

fig = px.bar(
    df, x='Operation', y='Time', color='Library',
    title='Operation Breakdown - 10M Dataset',
    barmode='group',  # <-- Magiczny parametr!
    color_discrete_sequence=Config.DP_COLORS
)

fig.update_layout(
    width=1000, height=500,
    xaxis_title="Operation",
    yaxis_title="Time (seconds)"
)

fig.write_html('chart2_operation_breakdown.html')
\end{lstlisting}

\textbf{Kluczowa obserwacja:} Parametr \texttt{barmode='group'} automatycznie
rozwiązuje złożony problem pozycjonowania 30 słupków (6 operacji × 5 bibliotek).

\subsubsection{Bokeh - Manualne Pozycjonowanie}

\begin{lstlisting}[caption={Chart 2: Grouped Bars - Bokeh (35 LOC)},label={lst:chart2_bokeh}]
df = Chart2_OperationBreakdown.prepare_data(dp_data)

operations = ['Loading', 'Cleaning', 'Aggregation', 
              'Sorting', 'Filtering', 'Correlation']

# MANUAL offset calculation for 5 libraries
x_offset = [-0.3, -0.15, 0, 0.15, 0.3]

p = figure(
    x_range=operations,
    title="Operation Breakdown - 10M Dataset",
    width=1000, height=500
)

# Loop through each library and calculate positions
for idx, lib in enumerate(Config.LIBRARIES):
    lib_data = df[df['LibraryCode'] == lib]
    if lib_data.empty:
        continue
    
    # Extract times for each operation
    times = [
        lib_data[lib_data['Operation'] == op]['Time'].values[0]
        if not lib_data[lib_data['Operation'] == op].empty 
        else 0
        for op in operations
    ]
    
    # Calculate x positions with offset
    x_positions = [i + x_offset[idx] 
                   for i in range(len(operations))]
    
    # Add bars for this library
    p.vbar(
        x=x_positions, top=times, width=0.12,
        color=Config.DP_COLORS[idx],
        legend_label=Config.LIBRARY_NAMES[lib]
    )

p.xaxis.axis_label = "Operation"
p.yaxis.axis_label = "Time (seconds)"
p.legend.location = "top_left"

output_file('chart2_operation_breakdown.html')
save(p)
\end{lstlisting}

\textbf{Analiza złożoności:}
\begin{itemize}
    \item Plotly: 10 linii, 1 parametr (\texttt{barmode='group'})
    \item Bokeh: 35 linii, manualne obliczenia x-offset
    \item \textbf{Różnica: 71\% więcej kodu w Bokeh}
\end{itemize}

% ============================================================================
\section{Porównanie Tabelaryczne}
% ============================================================================

\begin{table}[h]
\centering
\caption{Porównanie Lines of Code (LOC) dla 7 wykresów}
\label{tab:loc_summary}
\begin{tabular}{|l|c|c|c|c|c|}
\hline
\textbf{Wykres} & \textbf{Bokeh} & \textbf{Holoviews} & \textbf{Matplotlib} & \textbf{Plotly} & \textbf{Streamlit} \\
\hline
Chart 1: Execution Time & 25 & 12 & 20 & 8 & 15 \\
Chart 2: Operation Breakdown & 35 & 15 & 25 & 10 & 18 \\
Chart 3: Memory Usage (DP) & 24 & 12 & 19 & 8 & 14 \\
Chart 4: Scalability & 28 & 16 & 22 & 10 & 20 \\
Chart 5: Training Time & 24 & 13 & 20 & 8 & 15 \\
Chart 6: Inference Speed & 25 & 13 & 21 & 9 & 16 \\
Chart 7: Memory Usage (ML) & 24 & 12 & 19 & 8 & 14 \\
\hline
\textbf{Średnia} & \textbf{26.4} & \textbf{13.3} & \textbf{20.9} & \textbf{8.7} & \textbf{16.0} \\
\hline
\end{tabular}
\end{table}

% ============================================================================
\section{Wnioski}
% ============================================================================

\subsection{Ranking Prostoty (LOC)}

\begin{enumerate}
    \item \textbf{Plotly Express}: 8.7 LOC średnio (najkrótsza implementacja)
    \item \textbf{Holoviews}: 13.3 LOC (deklaratywne API)
    \item \textbf{Streamlit}: 16.0 LOC (dashboard framework)
    \item \textbf{Matplotlib}: 20.9 LOC (kontrola nad każdym elementem)
    \item \textbf{Bokeh}: 26.4 LOC (niskopoziomowe API)
\end{enumerate}

\subsection{Rekomendacje}

\begin{itemize}
    \item \textbf{Dla pracy magisterskiej (PDF)}: Matplotlib - najwyższa jakość druku
    \item \textbf{Dla prototypowania}: Plotly - najszybsze tworzenie wykresów
    \item \textbf{Dla appendixu interaktywnego}: Plotly/Holoviews - HTML
    \item \textbf{Dla maksymalnej kontroli}: Bokeh - dostęp do każdego elementu
    \item \textbf{Dla prezentacji (obrona)}: Streamlit - live dashboard
\end{itemize}

\subsection{Główne Odkrycia}

\begin{enumerate}
    \item \textbf{Deklaratywne API redukuje kod o 50-70\%}: 
    Plotly i Holoviews wymagają znacznie mniej kodu niż Bokeh i Matplotlib.
    
    \item \textbf{Grouped bars to test complexity}: 
    Różnice są najbardziej widoczne przy złożonych układach (Chart 2).
    
    \item \textbf{Matplotlib wciąż niezbędny}: 
    Mimo większej złożoności, pozostaje standardem dla publikacji naukowych.
    
    \item \textbf{Trade-off między prostotą a kontrolą}: 
    Krótszy kod (Plotly) = mniej kontroli; Dłuższy kod (Bokeh) = pełna kontrola.
\end{enumerate}

% ============================================================================
\section{Appendix: Pełny Kod Framework}
% ============================================================================

Framework testowy dostępny w pliku: \\
\texttt{comparative\_visualization\_thesis.py} (2100+ linii)

\begin{itemize}
    \item Sekcja 1-2: Configuration \& Data Loading
    \item Sekcja 3-9: 7 wykresów × 5 implementacji = 35 funkcji
    \item Sekcja 10: Report generation
\end{itemize}

Repozytorium: [Link do GitHub]

\end{document}
